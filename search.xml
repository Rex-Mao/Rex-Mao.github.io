<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Operating System | Ucore-Lab4</title>
      <link href="/2021/07/21/Operating-System-Ucore-Lab4/"/>
      <url>/2021/07/21/Operating-System-Ucore-Lab4/</url>
      
        <content type="html"><![CDATA[<h2 id="Presupposition"><a href="#Presupposition" class="headerlink" title="Presupposition"></a>Presupposition</h2><p>In this lab, we will not differ (process, thread) and (pcb, tcb). Because based on the presupposition, we can just create kernel thread.</p><h2 id="Practices-amp-Conclusion"><a href="#Practices-amp-Conclusion" class="headerlink" title="Practices &amp; Conclusion"></a>Practices &amp; Conclusion</h2><h3 id="Practice-1"><a href="#Practice-1" class="headerlink" title="Practice 1"></a>Practice 1</h3><ul><li><p>The process control block in ucore is designed like this</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct proc_struct &#123;</span><br><span class="line">    enum proc_state state;                      // Process state</span><br><span class="line">    int pid;                                    // Process ID</span><br><span class="line">    int runs;                                   // the running times of Proces</span><br><span class="line">    uintptr_t kstack;                           // Process kernel stack</span><br><span class="line">    volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?</span><br><span class="line">    struct proc_struct *parent;                 // the parent process</span><br><span class="line">    struct mm_struct *mm;                       // Process&#x27;s memory management field</span><br><span class="line">    struct context context;                     // Switch here to run process</span><br><span class="line">    struct trapframe *tf;                       // Trap frame for current interrupt</span><br><span class="line">    uintptr_t cr3;                              // CR3 register: the base addr of Page Directroy Table(PDT)</span><br><span class="line">    uint32_t flags;                             // Process flag</span><br><span class="line">    char name[PROC_NAME_LEN + 1];               // Process name</span><br><span class="line">    list_entry_t list_link;                     // Process link list </span><br><span class="line">    list_entry_t hash_link;                     // Process hash list</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>The context struct is used for saving or restoring registers when switching the running process, it records the context of one process. We save the fork return address as <code>context.eip</code>, so the newly process will start at fork return in this lab.</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct context &#123;</span><br><span class="line">    uint32_t eip;</span><br><span class="line">    uint32_t esp;</span><br><span class="line">    uint32_t ebx;</span><br><span class="line">    uint32_t ecx;</span><br><span class="line">    uint32_t edx;</span><br><span class="line">    uint32_t esi;</span><br><span class="line">    uint32_t edi;</span><br><span class="line">    uint32_t ebp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>The trapframe struct can be writen when interrupt occurred, cpu will reset to run the ISR and find the corresponding handler. Then the trapframe would be used to parse and handle the interrupt. In this lab, we use trapframe as the first stack frame to initialize the process stack, so that when newly process starting at fork return address and jumping to trapret func, trapret will reset the current esp to trapframe.tf_esp, when iret done, cpu will be set up totally to run the <code>kernel_thread_entry</code> which is a wrapped function to redirect the function what we request before.</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct trapframe &#123;</span><br><span class="line">    struct pushregs tf_regs;</span><br><span class="line">    uint16_t tf_gs;</span><br><span class="line">    uint16_t tf_padding0;</span><br><span class="line">    uint16_t tf_fs;</span><br><span class="line">    uint16_t tf_padding1;</span><br><span class="line">    uint16_t tf_es;</span><br><span class="line">    uint16_t tf_padding2;</span><br><span class="line">    uint16_t tf_ds;</span><br><span class="line">    uint16_t tf_padding3;</span><br><span class="line">    uint32_t tf_trapno;</span><br><span class="line">    /* below here defined by x86 hardware */</span><br><span class="line">    uint32_t tf_err;</span><br><span class="line">    uintptr_t tf_eip;</span><br><span class="line">    uint16_t tf_cs;</span><br><span class="line">    uint16_t tf_padding4;</span><br><span class="line">    uint32_t tf_eflags;</span><br><span class="line">    /* below here only when crossing rings, such as from user to kernel */</span><br><span class="line">    uintptr_t tf_esp;</span><br><span class="line">    uint16_t tf_ss;</span><br><span class="line">    uint16_t tf_padding5;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure></li></ul><h3 id="Practice-2"><a href="#Practice-2" class="headerlink" title="Practice 2"></a>Practice 2</h3><h4 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem 1"></a>Problem 1</h4><p>The following codes had shown the processing of do_fork().</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//    1. call alloc_proc to allocate a proc_struct</span><br><span class="line">if ((proc = alloc_proc()) == NULL) &#123;</span><br><span class="line">    goto fork_out;</span><br><span class="line">&#125;</span><br><span class="line">proc-&gt;parent = current;</span><br><span class="line"></span><br><span class="line">//    2. call setup_kstack to allocate a kernel stack for child process</span><br><span class="line">if (setup_kstack(proc) != 0) &#123;</span><br><span class="line">    goto bad_fork_cleanup_proc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//    3. call copy_mm to dup OR share mm according clone_flag</span><br><span class="line">if (copy_mm(clone_flags, proc) != 0) &#123;</span><br><span class="line">    goto bad_fork_cleanup_kstack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//    4. call copy_thread to setup tf &amp; context in proc_struct</span><br><span class="line">copy_thread(proc, stack, tf);</span><br><span class="line"></span><br><span class="line">//    5. insert proc_struct into hash_list &amp;&amp; proc_list</span><br><span class="line">bool intr_flag;</span><br><span class="line">local_intr_save(intr_flag);</span><br><span class="line">&#123;</span><br><span class="line">    proc-&gt;pid = get_pid();</span><br><span class="line">    hash_proc(proc);</span><br><span class="line">    list_add(&amp;proc_list, &amp;(proc-&gt;list_link));</span><br><span class="line">    nr_process ++;</span><br><span class="line">&#125;</span><br><span class="line">local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">//    6. call wakeup_proc to make the new child process RUNNABLE</span><br><span class="line">wakeup_proc(proc);</span><br><span class="line"></span><br><span class="line">//    7. set ret vaule using child proc&#x27;s pid</span><br><span class="line">ret = proc-&gt;pid;</span><br></pre></td></tr></table></figure><p>Notice: </p><ul><li>Step 3 has decided the way to operating the memory, duplicate or share with its parent.</li></ul><h4 id="Problem-2"><a href="#Problem-2" class="headerlink" title="Problem 2"></a>Problem 2</h4><p>Ucore can assign an unique process id for each process control block. First, Step 5 in Prob.1 has shown us that it will do the assigning opertion with interrupt disabled by command <code>local_intr_save(intr_flag)</code>, because of that, cpu will not be rescheduled to other threads or processes until <code>local_intr_restore(intr_flag)</code> called. Secondly, the logic of <code>get_pid()</code>, which use two parameters <code>last_pid</code> and <code>next_safe</code> to ensure a safe interval can be used, ensures an unique pid assigned with an acceptable time complexity.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// get_pid - alloc a unique pid for process</span><br><span class="line">static int</span><br><span class="line">get_pid(void) &#123;</span><br><span class="line">    static_assert(MAX_PID &gt; MAX_PROCESS);</span><br><span class="line">    struct proc_struct *proc;</span><br><span class="line">    list_entry_t *list = &amp;proc_list, *le;</span><br><span class="line">    static int next_safe = MAX_PID, last_pid = MAX_PID;</span><br><span class="line">    if (++ last_pid &gt;= MAX_PID) &#123;</span><br><span class="line">        last_pid = 1;</span><br><span class="line">        goto inside;</span><br><span class="line">    &#125;</span><br><span class="line">    if (last_pid &gt;= next_safe) &#123;</span><br><span class="line">    inside:</span><br><span class="line">        next_safe = MAX_PID;</span><br><span class="line">    repeat:</span><br><span class="line">        le = list;</span><br><span class="line">        while ((le = list_next(le)) != list) &#123;</span><br><span class="line">            proc = le2proc(le, list_link);</span><br><span class="line">            if (proc-&gt;pid == last_pid) &#123;</span><br><span class="line">                if (++ last_pid &gt;= next_safe) &#123;</span><br><span class="line">                    if (last_pid &gt;= MAX_PID) &#123;</span><br><span class="line">                        last_pid = 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    next_safe = MAX_PID;</span><br><span class="line">                    goto repeat;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (proc-&gt;pid &gt; last_pid &amp;&amp; next_safe &gt; proc-&gt;pid) &#123;</span><br><span class="line">                next_safe = proc-&gt;pid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return last_pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Practice-3"><a href="#Practice-3" class="headerlink" title="Practice 3"></a>Practice 3</h3><h4 id="Problem-1-1"><a href="#Problem-1-1" class="headerlink" title="Problem 1"></a>Problem 1</h4><p>In lab4, ucore created 2 processes: idle and init.<br>Ucore created a pcb named <code>idle</code> in the final stages then it set current process to idle. Idle process is used to run in idle status or switch the running processes. Init process is just used to print string in this lab, it will change to be more functional in the following labs. When the ucore running to cpu idle, the control will be handed to idle or another processes which is can be scheduled.</p><h4 id="Problem-2-1"><a href="#Problem-2-1" class="headerlink" title="Problem 2"></a>Problem 2</h4><p>Codes of proc_run:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// proc_run - make process &quot;proc&quot; running on cpu</span><br><span class="line">// NOTE: before call switch_to, should load  base addr of &quot;proc&quot;&#x27;s new PDT</span><br><span class="line">void</span><br><span class="line">proc_run(struct proc_struct *proc) &#123;</span><br><span class="line">    if (proc != current) &#123;</span><br><span class="line">        bool intr_flag;</span><br><span class="line">        struct proc_struct *prev = current, *next = proc;</span><br><span class="line">        local_intr_save(intr_flag);</span><br><span class="line">        &#123;</span><br><span class="line">            current = proc;</span><br><span class="line">            load_esp0(next-&gt;kstack + KSTACKSIZE);</span><br><span class="line">            lcr3(next-&gt;cr3);</span><br><span class="line">            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</span><br><span class="line">        &#125;</span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In these codes, <code>local_intr_save(intr_flag)</code> and <code>local_intr_restore(intr_flag)</code> disabled the interrupt to ensure cpu executing commands in an atomic status which means it can not be interrputted. Because of that, registers of cpu can be restore and reset with security. </p>]]></content>
      
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Operating System | Ucore-Lab3</title>
      <link href="/2021/07/17/Operating-System-Ucore-Lab3/"/>
      <url>/2021/07/17/Operating-System-Ucore-Lab3/</url>
      
        <content type="html"><![CDATA[<h2 id="Presupposition"><a href="#Presupposition" class="headerlink" title="Presupposition"></a>Presupposition</h2><ol><li>Virtual Memory Layout is shown as follow<br> <img src="/images/VirtualMemoryLayout.png" alt="VirtualMemoryLayout"></li><li>Virtual memory area (VMA)<br> The kernel uses virtual memory areas to keep track of the process’s memory mappings; for example, a process has one VMA for its code, one VMA for each type of data, one VMA for each distinct memory mapping (if any), and so on. VMAs are processor-independent structures, with permissions and access control flags. Each VMA has a start address, a length, and their sizes are always a multiple of the page size (PAGE_SIZE). A VMA consists of a number of pages, each of which has an entry in the page table.</li><li>VMA Addition and Removal<ul><li>Occurs whenever a new file is mmaped, a new shared memory segment is created, or a new section is created (e.g.,library, code, heap, stack)</li><li>Kernel tries to merge with adjacent sections</li></ul></li><li>Demand Fetching and Page Fault<ul><li><img src="/images/DemandFetchingAndPageFault.png" alt="DemandFetchingAndPageFault"></li></ul></li><li>Copy on Write<ul><li>PTE entry is marked as un-writeable</li><li>But VMA is marked as writeable</li><li>Page fault handler notices difference<ul><li>Must mean CoW</li><li>Make a duplicate of physical page</li><li>Update PTEs, flush TLB entry</li><li>do_wp_page</li></ul></li><li>How does COW work?<ul><li>Memory regions:<ul><li>New copies of all VMAs are allocated for child during fork</li><li>As are page tables</li></ul></li><li>Pages in memory:<ul><li>In page table (and in-memory representation), clear write bit, set COW bit</li><li>Is the COW bit hardware specified?</li><li>No, OS uses one of the available bits in the PTE</li><li>But it does not have to; can just keep the info in the VMA like other meta data</li><li>Make a new, writeable copy on a write page fault</li></ul></li></ul></li></ul></li><li>PFRA(Page Frame Reclaim Algorithm) invoked on three different occasions:<ul><li>Kernel detects low on memory condition<ul><li>E.g., during alloc_pages</li></ul></li><li>Periodic reclaiming<ul><li>kernel thread kswapd</li></ul></li><li>Hibernation reclaiming<ul><li>for suspend-to-disk</li></ul></li></ul></li></ol><h2 id="Practices-amp-Conclusion"><a href="#Practices-amp-Conclusion" class="headerlink" title="Practices &amp; Conclusion"></a>Practices &amp; Conclusion</h2><h3 id="Practice-0"><a href="#Practice-0" class="headerlink" title="Practice 0"></a>Practice 0</h3><p>Use software - meld to merge the codes. ^-^, better than diff &amp; patch command!</p><h3 id="Prcatice-1"><a href="#Prcatice-1" class="headerlink" title="Prcatice 1"></a>Prcatice 1</h3><h4 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem 1"></a>Problem 1</h4><p>First, we should know the consist of the Page Directory&#x2F;Table Entry.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* page table/directory entry flags */</span><br><span class="line">#define PTE_P           0x001                   // Present</span><br><span class="line">#define PTE_W           0x002                   // Writeable</span><br><span class="line">#define PTE_U           0x004                   // User</span><br><span class="line">#define PTE_PWT         0x008                   // Write-Through</span><br><span class="line">#define PTE_PCD         0x010                   // Cache-Disable</span><br><span class="line">#define PTE_A           0x020                   // Accessed</span><br><span class="line">#define PTE_D           0x040                   // Dirty</span><br><span class="line">#define PTE_PS          0x080                   // Page Size</span><br><span class="line">#define PTE_MBZ         0x180                   // Bits must be zero</span><br><span class="line">#define PTE_AVAIL       0xE00                   // Available for software use</span><br><span class="line">                                                // The PTE_AVAIL bits aren&#x27;t used by the kernel or interpreted by the</span><br><span class="line">                                                // hardware, so user processes are allowed to set them arbitrarily.</span><br></pre></td></tr></table></figure><p>Accroding to this description, when we want to check or alloc pde&#x2F;pte, we can easily know the present, writeable, user flags, etc. The present flag can be used when doing page reclamation to check if the virtual page is in page frame which the pde&#x2F;pte mapped. With using of the writeable flages and vma flags, CoW(Copy on Write) can be implemented.</p><h4 id="Problem-2"><a href="#Problem-2" class="headerlink" title="Problem 2"></a>Problem 2</h4><p>When page fault raised, some handling operations for exceptions should be done by the hardwares. Cpu will save the exception linear address to the CR2 register and backup the current context in the kernel stack (push the EFLAGS, CS, EIP, errCode). Then load the interrupt service address to cs and eip to run the corresponding handling services. After the fault handled, cpu need to restore the registers and exception application context.</p><h3 id="Prcatice-2"><a href="#Prcatice-2" class="headerlink" title="Prcatice 2"></a>Prcatice 2</h3><p>The current swap manager can support the extended clock ALGO.</p><ol><li><p>Extended clock ALGO.</p><p> It can be implemented by adding a “second chance” bit to each memory frame, every time the frame is considered (due to a reference made to the page inside it), this bit is set to 1, which gives the page a second chance, as when we consider the candidate page for replacement, we replace the first one with this bit set to 0 (while zeroing out bits of the other pages we see in the process). Thus, a page with the “second chance” bit set to 1 is never replaced during the first consideration and will only be replaced if all the other pages deserve a second chance too!</p></li><li><p>Timing to swap-in or swap-out</p><p> We can use PTE to record the second bit (dirty bit) and differ those pages. Swap out had two different way to achieve, positive and negative way. The positive way means that operating system will check the page table periodly and do the swap in or out operations, it can be implemented by the clock interrup. The negative way corresponds that swap in or out the target page when using. What we should notice is, when doing swap-out operations, we need to swap it out to the disk directly or record the changes when a dirty page (which is changed in memory) to merge several changes.</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Operating System | Ucore-Lab2</title>
      <link href="/2021/07/06/Operating-System-Ucore-Lab2/"/>
      <url>/2021/07/06/Operating-System-Ucore-Lab2/</url>
      
        <content type="html"><![CDATA[<h2 id="Presupposition"><a href="#Presupposition" class="headerlink" title="Presupposition"></a>Presupposition</h2><ol><li>First we should notice a 32-bits register can store 2^32 different RAM addresses. Each RAM address corresponds to a Byte(8 bits) in modern RAMs. So a 32-bit register can corresponds (2^32 * 2^3) which equals 4GB.</li><li>About the kernel boot and memory detect, init, map processing are as follow.<ol><li><p>What we should know secondly is, before the kernal started, the bootloader had enable the a20 and protected segment mode. After that we got a mapping (VA &#x3D; LA &#x3D; PA) with base addr 0x0. </p></li><li><p>In kernel.ld, it defined the new base, text(code&#x2F;text segment), data(it used for store initalized global varibles), bss(Block Started by Symbol, segment bss is a memory space used for store the un-initalize global varibles, it belongs to static memory allocation) addrress under the segment mode by lgdt. </p></li><li><p>After loading kernel.ld and executing the entry.S had modified the based addr to 0xC0000000. They tune the kernel start linked addr to virtual address(VA) 0xC0100000. Of course, this VA(0xC0100000) mapping to the PA (0x00100000 &#x3D; 1*(2^4)^5 &#x3D; 2^20 RAM addresses, 2^20B &#x3D; 1MB size in RAM memory). We had achieved the mapping (VA|LA &#x3D; PA + 0xC0000000).</p></li><li><p>Detect the physical memory layout by e820 then map and init pages descriptors and the free page list Now, we can use alloc and free opertions of pages.</p></li><li><p>Alloc a page frame(4KB) for boot_pgdir(virtual address corresponds to this page frame) and use it to store the page table. 4KB can store 1024 ptes(32bit, 4B), which means 1024 * 4B &#x3D; 4MB physical memory. Set its physical memory address to boot_pgdir[PDX(VPT)] which points itself in virtual page table.</p></li><li><p>Remap the segment memory layout by boot_map_segment. Via mapping the pte and physical memory address, it maps all linear address (KERNBASE ~ KERNBASE + KMEMSIZE) to the physical address (0 ~ KMEMSIZE). Now we get a full size page table mapping to KMEMSIZE physical memory.</p></li><li><p><code>boot_pgdir[0] = boot_pgdir[PDX(KERNBASE)]</code> Set a temporary mapping for kernel code and data, which will be used by cpu low addr to high addr switch. It allocs just one pde means 2^10 * 4KB &#x3D; 4MB for temporary memory so that kernel may be crash if it’s not enough. The solution will be allocing more temporary memory for kernel info before switch.</p></li><li><p>Refresh the cr3(pgdir) and cr0(paging flag) to enable the paging mode</p></li><li><p>Init the TSS then realod the gdt.<br> The task state segment (TSS) is a structure on x86-based computers which holds information about a task. It is used by the operating system kernel for task management. Specifically, the following information is stored in the TSS:</p><ul><li>Processor register state</li><li>I&#x2F;O port permissions</li><li>Inner-level stack pointers</li><li>Previous TSS link</li></ul></li><li><p>Cancel the temporary memory mapping of boot_pgdir[0] which used in cpu running address switches.</p></li></ol></li><li>Page descriptor is using for describing the memory perporties. Page table is using for mapping the virtual and physical address.</li><li>Virtual memory map of Ucore is as follow <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* *</span><br><span class="line">* Virtual memory map:                                          Permissions</span><br><span class="line">*                                                              kernel/user</span><br><span class="line">*</span><br><span class="line">*     4G ------------------&gt; +---------------------------------+</span><br><span class="line">*                            |                                 |</span><br><span class="line">*                            |         Empty Memory (*)        |</span><br><span class="line">*                            |                                 |</span><br><span class="line">*                            +---------------------------------+ 0xFB000000</span><br><span class="line">*                            |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE  -- use 4KB =&gt; 2^10 pdes =&gt;  2^20 ptes =&gt; 2^20 * Page Frame(4KB) = 4G Physical Memory</span><br><span class="line">*     VPT -----------------&gt; +---------------------------------+ 0xFAC00000</span><br><span class="line">*                            |        Invalid Memory (*)       | --/--</span><br><span class="line">*     KERNTOP -------------&gt; +---------------------------------+ 0xF8000000</span><br><span class="line">*                            |                                 |</span><br><span class="line">*                            |    Remapped Physical Memory     | RW/-- KMEMSIZE(896MB)</span><br><span class="line">*                            |                                 |</span><br><span class="line">*     KERNBASE ------------&gt; +---------------------------------+ 0xC0000000</span><br><span class="line">*                            |                                 |</span><br><span class="line">*                            |                                 |</span><br><span class="line">*                            |                                 |</span><br><span class="line">*                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">* (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span><br><span class="line">*     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span><br><span class="line">*     there if desired.</span><br><span class="line">*</span><br><span class="line">* */</span><br></pre></td></tr></table></figure></li><li>Segmented Paging Memory Management</li></ol><ul><li><img src="/images/SegmentedPaging.png" alt="Segmented Paging Memory Management"></li></ul><h2 id="Practices-amp-Conclusion"><a href="#Practices-amp-Conclusion" class="headerlink" title="Practices &amp; Conclusion"></a>Practices &amp; Conclusion</h2><h3 id="Practice-0"><a href="#Practice-0" class="headerlink" title="Practice 0"></a>Practice 0</h3><p>For achieving the lab2 better, we need to use diff and patch to merge the code from lab1.</p><ul><li>diff  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">diff -Nu lab2/kern/debug/kdebug.c lab1/kern/debug/kdebug.c &gt;&gt; lab_merge.patch</span><br><span class="line">-N treat absent files as empty</span><br><span class="line">-u unified style, if your system lacks it or if recipient may not have it, use &quot;-c&quot;</span><br><span class="line">-r recursive, so do subdirectories</span><br></pre></td></tr></table></figure></li><li>patch  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">patch -p0 &lt; ../lab_merge.patch</span><br><span class="line">-s == silent except errors</span><br><span class="line">-p0 == needed to find the proper folder</span><br><span class="line">PS: use cd to origin path and use -p param to strip the path, like lab2/kern/debug/kdebug.c =&gt; -p1 = kern/debug/kdebug.c</span><br></pre></td></tr></table></figure></li><li>notes from web  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># to create patch:</span><br><span class="line"># copy &lt;directory&gt; backup to something like &lt;directory&gt;.orig alongside it</span><br><span class="line">cp -r &lt;path_to&gt;/&lt;directory&gt; &lt;path_to&gt;/&lt;directory&gt;.orig</span><br><span class="line"># create/update/delete files/folders in &lt;directory&gt; until desired state is reached</span><br><span class="line"># change working directory to &lt;directory&gt;</span><br><span class="line">cd &lt;path_to&gt;/&lt;directory&gt;</span><br><span class="line"># create patch file alongside &lt;directory&gt;</span><br><span class="line">diff -Naru ../&lt;directory&gt;.orig . &gt; ../file.patch</span><br><span class="line"># -N --new-file Treat absent files as empty.</span><br><span class="line"># -a --text Treat all files as text.</span><br><span class="line"># -r --recursive Recursively compare any subdirectories found.</span><br><span class="line"># -u -U NUM --unified[=NUM] Output NUM (default 3) lines of unified context.</span><br><span class="line"></span><br><span class="line"># to apply patch:</span><br><span class="line"># change working directory to &lt;directory&gt;</span><br><span class="line">cd &lt;path_to&gt;/&lt;directory&gt;</span><br><span class="line">patch -s -p0 &lt; &lt;path_to&gt;/file.patch</span><br><span class="line"># -s or --silent or --quiet Work silently, unless an error occurs.</span><br><span class="line"># -pN or --strip=N Strip smallest prefix containing num leading slashes from files.</span><br><span class="line"></span><br><span class="line"># to undo patch (note that directories created by patch must be removed manually):</span><br><span class="line"># change working directory to &lt;directory&gt;</span><br><span class="line">cd &lt;path_to&gt;/&lt;directory&gt;</span><br><span class="line">patch -Rs -p0 &lt; &lt;path_to&gt;/file.patch</span><br><span class="line"># -R or --reverse Assume that patch was created with the old and new files swapped.</span><br><span class="line"># -s or --silent or --quiet Work silently, unless an error occurs.</span><br><span class="line"># -pN or --strip=N Strip smallest prefix containing num leading slashes from files.</span><br></pre></td></tr></table></figure></li></ul><h3 id="Practice-1"><a href="#Practice-1" class="headerlink" title="Practice 1"></a>Practice 1</h3><p>In this practice, we achieved the first fit memory alloc ALGO. What we should notice is diffing the follows.</p><ul><li>physical address of RAM(memory)</li><li>page descriptor (size 4B, not page frame(4KB), one page frame can contain 2^10 Page descriptor) which record those pages info of physical addresses, stored at the address of ending of kernel. </li><li>free_list, corresponds a mutable list of usable page_link.</li></ul><p>We can use page_link of free_list to get the page descriptor with function le2page(). The alloc and free operations correspond to modifying the free_list and setting the flags and property of the pages. </p><p>As for first fit memory alloc algorithm, it asks us to find first continuous free pages from the free_list to alloc. We need to pay more attention to keep the free_list order by addresses and keep the mapping continuous in physical memory level when doing init, alloc and free operations.</p><ul><li>default_init: init a free pages list.</li><li>default_init_memmap: create page descriptor for every usable PGSIZE physical memory block detected by e820 and link them to the free pages list.</li><li>default_alloc_pages: find the first n continuous pages in free list, set some property, remove them from the free list and return the pointer points to the start page descriptor.</li><li>default_free_pages: clear up the page properties and relink them to free list, the continuity of the physical memory should be noticed.</li></ul><h3 id="Practice-2"><a href="#Practice-2" class="headerlink" title="Practice 2"></a>Practice 2</h3><h4 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem 1"></a>Problem 1</h4><p>First, the page directory entry corresponding to the virtual address range [VPT, VPT + PTSIZE) points to the page directory itself. Thus, the page directory is treated as a page table as well as a page directory.</p><p>Second, a linear address ‘la’ has a three-part structure as follows:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// +--------10------+-------10-------+---------12----------+</span><br><span class="line">// | Page Directory |   Page Table   | Offset within Page  |</span><br><span class="line">// |      Index     |     Index      |                     |</span><br><span class="line">// +----------------+----------------+---------------------+</span><br><span class="line">//  \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/</span><br><span class="line">//  \----------- PPN(la) -----------/</span><br></pre></td></tr></table></figure><p>According to that, we can get the pde&#x2F;pte as follows:</p><ul><li>Page Directory Entry (use high 10 bits to get)  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pde = (pte_base_addr &amp; ~0x0FFF) | PTE_U | PTE_W | PTE_P</span><br></pre></td></tr></table></figure></li><li>Page Table Entry (use mid 10 bits to get)  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pte = (physical_address  &amp; ~0x0FFF) | PTE_P | PTE_W</span><br></pre></td></tr></table></figure></li></ul><p>In ucore, we would need la and those two struct to get an physical address. What’s more important is we can change the pte value to change the mapping of the virtual address and physical address(start address of a page frame).</p><h4 id="Problem-2"><a href="#Problem-2" class="headerlink" title="Problem 2"></a>Problem 2</h4><p>When the processor visit an nonexistent page, a page fault(#PF) will happen. An interrupt will be triggered, then the interrupt handling service will be pushed to the stack and executed. If the visit is valid then the service will alloc a new page for the visit and refresh the TLB. Finally, call the iret to interrupt and jump back to the exception address and go on process. If the visit is invalid, error will be raised.</p><h3 id="Practice-3"><a href="#Practice-3" class="headerlink" title="Practice 3"></a>Practice 3</h3><h4 id="Problem-1-1"><a href="#Problem-1-1" class="headerlink" title="Problem 1"></a>Problem 1</h4><p>There is a mapping relation existed between page descriptors and pdes&#x2F;ptes. The transition is like the follow:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PTE =&gt; Page: use index which composited by high 20 bits of pte to get pages[index]</span><br><span class="line">&amp;pages[(</span><br><span class="line">    (</span><br><span class="line">        (uintptr_t)(</span><br><span class="line">            (</span><br><span class="line">                (uintptr_t)(pte) &amp; ~0xFFF</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    ) &gt;&gt; PTXSHIFT</span><br><span class="line">)]    </span><br></pre></td></tr></table></figure><h4 id="Problem-2-1"><a href="#Problem-2-1" class="headerlink" title="Problem 2"></a>Problem 2</h4><p>Reset KERNBASE from 从0xC0000000 to 0x00000000 will get the target which maps the VA&#x3D;LA&#x3D;PA</p>]]></content>
      
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Operating System | Ucore-Lab1</title>
      <link href="/2021/06/23/Operating-System-Ucore-Lab1/"/>
      <url>/2021/06/23/Operating-System-Ucore-Lab1/</url>
      
        <content type="html"><![CDATA[<h2 id="Presupposition"><a href="#Presupposition" class="headerlink" title="Presupposition"></a>Presupposition</h2><h3 id="Some-tips-in-assembly-language"><a href="#Some-tips-in-assembly-language" class="headerlink" title="Some tips in assembly language"></a>Some tips in assembly language</h3><ol><li>AT&amp;T verus Intel<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OP-code dst src //Intel</span><br><span class="line">OP-code src dst //AT&amp;T</span><br></pre></td></tr></table></figure></li><li>int : means making an interrupt<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">To make a system call on the x86, a program invokes the int n instruction, where</span><br><span class="line">n specifies the index into the IDT. The int instruction performs the following steps:</span><br><span class="line">• Fetch the n’th descriptor from the IDT, where n is the argument of int.</span><br><span class="line">• Check that CPL in %cs is &lt;= DPL, where DPL is the privilege level in the de-</span><br><span class="line">scriptor.</span><br><span class="line">• Save %esp and %ss in CPU-internal registers, but only if the target segment selec-</span><br><span class="line">tor’s PL &lt; CPL.</span><br><span class="line">• Load %ss and %esp from a task segment descriptor.</span><br><span class="line">• Push %ss.</span><br><span class="line">• Push %esp.</span><br><span class="line">• Push %eflags.</span><br><span class="line">• Push %cs.</span><br><span class="line">• Push %eip.</span><br><span class="line">• Clear some bits of %eflags.</span><br><span class="line">• Set %cs and %eip to the values in the descriptor.</span><br></pre></td></tr></table></figure></li><li>extended inline assembly<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asm ( assembler template</span><br><span class="line">    : output operands               -- optional --</span><br><span class="line">    : input operands                -- optional --</span><br><span class="line">    : list of clobbered registers   -- optional --</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol><h3 id="Some-usages-of-registers"><a href="#Some-usages-of-registers" class="headerlink" title="Some usages of registers"></a>Some usages of registers</h3><ol><li><p>General Registers</p><ul><li>AX (accumulator) ： use to accumulate</li><li>BX (base) ： base register, use to index the address</li><li>CX (count) ： counter</li><li>DX (data) ： use to data transfer</li></ul></li><li><p>Segment and pointer Reisters</p><ul><li>CS (code segment)</li><li>DS (data segment)</li><li>SS (stack segment)</li><li>ES (extra segment)</li><li>IP (instruction pointer)</li><li>SP (stack pointer)</li><li>BP (base pointer)</li></ul></li></ol><h3 id="Some-terminologies"><a href="#Some-terminologies" class="headerlink" title="Some terminologies"></a>Some terminologies</h3><ul><li>PIC : Programmable Interrupt Controller</li></ul><h2 id="Practices-amp-Conclusion"><a href="#Practices-amp-Conclusion" class="headerlink" title="Practices &amp; Conclusion"></a>Practices &amp; Conclusion</h2><h3 id="Practice-1"><a href="#Practice-1" class="headerlink" title="Practice 1"></a>Practice 1</h3><h4 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem 1"></a>Problem 1</h4><p>By the code, we can see that Makefile use gcc to do the compile operation to the source code with some libs step by step and output some object(.o) files. And then it uses ld to link those .o files and produce an executable object(obj&#x2F;bootblock.out). Then use sign tools to generate a standard bootblock.o. Finally, use dd to generate an ucore.img file.</p><ul><li>PS<ul><li>The ld command, also called the linkage editor or binder, combines object files, archives, and import files into one output object file, resolving external references. It produces an executable object file that can be run.</li><li>dd is a command-line utility for Unix and Unix-like operating systems whose primary purpose is to convert and copy files.</li></ul></li><li>From web  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GCC</span><br><span class="line">    -g  //add gdb debug info</span><br><span class="line">    -Wall  //to show the warnning info</span><br><span class="line">    -O2  //optimize processing (0，1，2，3，0 for no optimized)</span><br><span class="line">    -fno-builtin  //only accept the builtin function start with &quot;__&quot;</span><br><span class="line">    -ggdb  //let gcc generate more debug info for gdb</span><br><span class="line">    -m32  //build 32bits program</span><br><span class="line">    -gstabs  //generate debug info in stabs style without gdb debug info</span><br><span class="line">    -nostdinc  //do Not search header files in standard library, but use -l to specify</span><br><span class="line">    -fstack-protector-all  //enable the stack and heap protection, insert protection code for all functions</span><br><span class="line">    -E  //only do pre-handling, will not build and link</span><br><span class="line">    -x c  //specify the C language for explicition</span><br><span class="line"></span><br><span class="line">LDD Flags</span><br><span class="line">    -nostdlib  //do not link the std start and standard files, just transfer the specific file to linker</span><br><span class="line">    -m elf\_i386  //use elf_i386 simulator</span><br><span class="line">    -N  //set segment text and data readable and writable，cancel the page aligen in segment, cancel the link to shared library</span><br><span class="line">    -e func  //set the start point to symbol func</span><br><span class="line">    -Ttext addr  //redirect the start addr to addr when linking(i.e set 0 if not specify this))</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="Problem-2"><a href="#Problem-2" class="headerlink" title="Problem 2"></a>Problem 2</h4><p>We can get the check logic of the image from the tools&#x2F;sign.c. It shows us that an image size should less than 510 bytes and end with 0x55, 0xAA.</p><h3 id="Pratice-2-amp-3"><a href="#Pratice-2-amp-3" class="headerlink" title="Pratice 2 &amp; 3"></a>Pratice 2 &amp; 3</h3><p>In those pratices, we used gdb to debug the bootblock. The steps are as follow.</p><ol><li>The BIOS loads this code from the first sector of the hard disk into memory at physical address 0x7c00 and starts executing in real mode with %cs&#x3D;0 %ip&#x3D;7c00, so the cpu load the 0x7c00 for the first command.</li><li>Do something init like register eax, ds, es, ss. </li><li>Enable the A20 mode to be compatible with the low address(20bits) for using high address(like 32bits). If we don’t get A20 mode enabled, the address higher than 1MB(1088kb) will be wrapped around to zero by default in real mode. </li><li>Prepare the gdt and gdtdesc structure then use lgdt command to transport them to registers. </li><li>Set CR0 register (protected mode) to 1 so that we got protected mode enabled.<br>After the registers under the protected mode prepared, at this time, we had finished processor preparation to execute code with 32-bits address. Next, we will set the ebp and esp registers so that can execute bootmain.c.</li></ol><h3 id="Pratice-4"><a href="#Pratice-4" class="headerlink" title="Pratice 4"></a>Pratice 4</h3><h4 id="Problem-1-1"><a href="#Problem-1-1" class="headerlink" title="Problem 1"></a>Problem 1</h4><p>Wait for the disk ready, and then use the supported method of hardware like outb (outb(…, 0x20)) to send the command to read sectors. Use insl to read a sector from the io.</p><h4 id="Problem-2-1"><a href="#Problem-2-1" class="headerlink" title="Problem 2"></a>Problem 2</h4><p>First, we use the readseg method to load the ELFHDR from the kernel image(disk) to the virtual address @va. Then we use the the info stored in the ELFHDR to load the program content to the @va. Then the bootloader will call the entry point of kernel from the ELF Header so that the kernel code will take over the hardware.</p><h3 id="Practice-5"><a href="#Practice-5" class="headerlink" title="Practice 5"></a>Practice 5</h3><p>In this practice, we can use ebp and eip cleverly to trace the stackframe step by step. What we should do is getting the current ebp and eip value. With eip, we can get the debug info in current layer. Ebp’s value contains the last function ebp address before it. We can also use this ebp value to get the function params(ebp+2) and return addr (the address which should jump to when the sub function done, should taken by eip). We can trace those registers layer by layer until reach the ebp&#x3D;0(means the address which the bootloader start the kernel) or the STACKFRAME_DEPTH.</p><ul><li>PS<ul><li>Function Stack is built from high address to low address, so that we can use ebp+1 to get the last eip register value(the address which can return to last function to resume the processing)</li><li>Memory layout<br>  <img src="/images/MemoryLayout.jpg" alt="MemoryLayout"></li><li>Function stack frame<br>  <img src="/images/FunctionStackFrame.jpg" alt="FunctionStackFrame"></li></ul></li></ul><h3 id="Practice-6"><a href="#Practice-6" class="headerlink" title="Practice 6"></a>Practice 6</h3><h4 id="Problem-1-2"><a href="#Problem-1-2" class="headerlink" title="Problem 1"></a>Problem 1</h4><p>In ucore, we can find the gatedesc at &#x2F;kern&#x2F;mm&#x2F;mmu.h.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* Gate descriptors for interrupts and traps */</span><br><span class="line">struct gatedesc &#123;</span><br><span class="line">    unsigned gd_off_15_0 : 16;        //low 16 bits of offset in segment</span><br><span class="line">    unsigned gd_ss : 16;            //segment selector</span><br><span class="line">    unsigned gd_args : 5;            //# args, 0 for interrupt/trap gates</span><br><span class="line">    unsigned gd_rsv1 : 3;            //reserved(should be zero I guess)</span><br><span class="line">    unsigned gd_type : 4;            //type(STS_&#123;TG,IG32,TG32&#125;)</span><br><span class="line">    unsigned gd_s : 1;                //must be 0 (system)</span><br><span class="line">    unsigned gd_dpl : 2;            //descriptor(meaning new) privilege level</span><br><span class="line">    unsigned gd_p : 1;                //Present</span><br><span class="line">    unsigned gd_off_31_16 : 16;        //high bits of offset in segment</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>According to the structure, we can know that an item consist of 64bit aka 8bytes.<br>The low 16-32 bits saved the segment selector and we can use this to query segdesc from the GDT so that we can get the segment base address.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Charset &amp; Encoding</title>
      <link href="/2020/06/17/Charset-Encoding/"/>
      <url>/2020/06/17/Charset-Encoding/</url>
      
        <content type="html"><![CDATA[<h2 id="Charset"><a href="#Charset" class="headerlink" title="Charset"></a>Charset</h2><p>Charset is the set of characters. For example, GB2312(charset) has contained basic simplified chinese characters; Unicode(charset) has contained 144697 characters of 22 languages.</p><h2 id="Encoding"><a href="#Encoding" class="headerlink" title="Encoding"></a>Encoding</h2><p>Encodings map the character and the binary code representation. It depends the way these characters are stored into memory. When u want to transport some bytes, it should be encode and decode in the same encodings, otherwise u will get wrong results. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; text = u&#x27;您好&#x27;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; text_bytes_8 = text.encode(&#x27;utf-8&#x27;)</span><br><span class="line">&gt;&gt;&gt; text_bytes_8</span><br><span class="line">b&#x27;\xe6\x82\xa8\xe5\xa5\xbd&#x27;</span><br><span class="line"># 2 hex-based [2^4 * 2^4] bits can be represent by 8 binary-based bits [2^8]</span><br><span class="line"># \xe6 [ e6 = 14 * 16^1 + 6 * 16^0 = 230 = 1110 0110]</span><br><span class="line">&gt;&gt;&gt; text_bytes_8.decode(&#x27;utf-8&#x27;)</span><br><span class="line">&#x27;您好&#x27;</span><br><span class="line">&gt;&gt;&gt; text_bytes_8.decode(&#x27;utf-16&#x27;)</span><br><span class="line">&#x27;苦\ue5a8붥&#x27;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; text_bytes_16 = text.encode(&#x27;utf-16&#x27;)</span><br><span class="line">&gt;&gt;&gt; text_bytes_16</span><br><span class="line">b&#x27;\xff\xfe\xa8`&#125;Y&#x27;</span><br><span class="line">&gt;&gt;&gt; text_bytes_16.decode(&#x27;utf-16&#x27;)</span><br><span class="line">&#x27;您好&#x27;</span><br><span class="line">&gt;&gt;&gt; text_bytes_16.decode(&#x27;utf-8&#x27;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;input&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">UnicodeDecodeError: &#x27;utf-8&#x27; codec can&#x27;t decode byte 0xff in position 0: invalid start byte</span><br></pre></td></tr></table></figure><h2 id="Relationship"><a href="#Relationship" class="headerlink" title="Relationship"></a>Relationship</h2><p>Every charset maybe contain one or more encodings, like Unicode. Unicode charset has utf-8, utf-16, ucs-2 encodings.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Initialize the blog</title>
      <link href="/2020/04/26/Initialize-the-blog/"/>
      <url>/2020/04/26/Initialize-the-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="Get-started"><a href="#Get-started" class="headerlink" title="Get started"></a>Get started</h2><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p>Since today, i would like to <strong>record something stupid</strong> and the log of playing the role of geek in my daily life.</p><h3 id="Contact-Me"><a href="#Contact-Me" class="headerlink" title="Contact Me"></a>Contact Me</h3><p>U can contact me with <a href="mailto:rexalun99@gmail.com">email</a>.</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
